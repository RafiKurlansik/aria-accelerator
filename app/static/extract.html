<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extract Questions - ARIA</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="/static/images/icons/databricks-ARIA-icon-full-color.svg">
    <link rel="alternate icon" href="/static/images/icons/databricks-ARIA-icon-full-color.svg">
    <link rel="mask-icon" href="/static/images/icons/databricks-ARIA-icon-full-color.svg" color="#FF3621">
    
    <link rel="stylesheet" href="/static/css/main.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&display=swap" rel="stylesheet">
    
    <style>
        /* Enhanced table styling */
        #questionsTable {
            font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
        }
        
        #questionsTable tbody tr:hover {
            background-color: #f8f9fa !important;
        }
        
        .editable-cell {
            border: 1px solid transparent;
            cursor: text;
        }
        
        .editable-cell:hover {
            border-color: #e0e0e0 !important;
            background-color: #f8f9fa !important;
        }
        
        .editable-cell:focus {
            border-color: #2563eb !important;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1) !important;
        }
        
        /* Responsive table */
        @media (max-width: 768px) {
            #questionsTableContainer {
                font-size: 12px;
            }
            
            #questionsTable th,
            #questionsTable td {
                padding: 8px !important;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="container">
            <div style="display: flex; align-items: center; gap: 15px;">
                <img src="/static/images/logos/databricks-ARIA-lockup-full-color-stacked.svg" alt="ARIA Logo" style="height: 50px;">
                <h1>Analyst Relations Intelligent Assistant</h1>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Mode Navigation -->
        <div class="nav-tabs">
            <a href="/" class="nav-tab active">üìÑ RFI Processor</a>
            <a href="/chat" class="nav-tab">üí¨ Chat</a>
            <a href="/audit" class="nav-tab">üîç Document Audit</a>
        </div>

        <div class="main-content">
            <div class="content-area">
                <!-- Progress Stepper -->
                <div class="stepper">
                    <div class="step completed">
                        <div class="step-circle">‚úì</div>
                        <div class="step-label">Upload</div>
                    </div>
                    <div class="step active">
                        <div class="step-circle">2</div>
                        <div class="step-label">Extract</div>
                    </div>
                    <div class="step">
                        <div class="step-circle">3</div>
                        <div class="step-label">Generate</div>
                    </div>
                    <div class="step">
                        <div class="step-circle">4</div>
                        <div class="step-label">Download</div>
                    </div>
                </div>

                <h2>üìã Extract Questions</h2>
                <p>AI will analyze your document and extract questions for response generation.</p>

                <!-- Document Status -->
                <div id="documentStatus" class="form-section">
                    <div class="alert alert-info">
                        <span class="loading"></span> Loading document information...
                    </div>
                </div>

                <!-- Extraction Configuration -->
                <div id="extractionConfig" class="form-section" style="display: none;">
                    <h3>‚öôÔ∏è Extraction Settings</h3>
                    
                    <div class="form-group">
                        <label for="modelSelection">Model</label>
                        <select id="modelSelection" class="form-input">
                            <option value="databricks-claude-sonnet-4">Claude 4 Sonnet (Default)</option>
                            <option value="databricks-claude-3-7-sonnet">Claude 3.7 Sonnet</option>
                            <option value="databricks-gpt-oss-120b">GPT OSS 120B</option>
                        </select>
                        <div class="help-text">Select the AI model to use for question extraction</div>
                    </div>
                    
                    <div class="form-group">
                        <label for="customPrompt">Custom Instructions (Optional)</label>
                        <textarea id="customPrompt" class="form-input" placeholder="E.g., in this document, questions are framed as requirements." rows="3"></textarea>
                        <div class="help-text">Leave blank to use default extraction prompts</div>
                    </div>
                    
                    <button id="extractBtn" class="btn btn-primary">
                        üîç Extract Questions
                    </button>
                    <button class="btn btn-secondary" onclick="window.location.href='/'">
                        ‚Üê Back to Upload
                    </button>
                </div>

                <!-- Extraction Results -->
                <div id="extractionResults" class="form-section" style="display: none;">
                    <h3>üìù Extracted Questions</h3>
                    <div class="alert alert-success" id="successMessage">
                        Successfully extracted questions from your document.
                    </div>
                    
                    <!-- Questions Table -->
                    <div id="questionsTableContainer" style="margin: 20px 0;">
                        <div style="background: white; border: 1px solid #e0e0e0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                            <div style="background: #f8f9fa; padding: 15px; border-bottom: 1px solid #e0e0e0;">
                                <h4 style="margin: 0; color: #495057;">üìã Question Details</h4>
                                <p style="margin: 5px 0 0 0; font-size: 14px; color: #666;">Click on cells to edit content. Changes are saved automatically.</p>
                            </div>
                            <div style="overflow-x: auto; max-height: 600px; overflow-y: auto;">
                                <table id="questionsTable" style="width: 100%; border-collapse: collapse;">
                                    <thead style="background: #f8f9fa; position: sticky; top: 0; z-index: 10;">
                                        <tr>
                                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #e0e0e0; font-weight: 600; color: #495057; width: 100px;">Question ID</th>
                                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #e0e0e0; font-weight: 600; color: #495057; width: 200px;">Topic</th>
                                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #e0e0e0; font-weight: 600; color: #495057; width: 120px;">Sub-Question ID</th>
                                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #e0e0e0; font-weight: 600; color: #495057;">Question Text</th>
                                        </tr>
                                    </thead>
                                    <tbody id="questionsTableBody">
                                        <!-- Table rows will be populated here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <button id="proceedToGenerate" class="btn btn-success">
                            ‚û°Ô∏è Proceed to Answer Generation
                        </button>
                        <button id="reExtract" class="btn btn-secondary">
                            üîÑ Re-extract with Different Settings
                        </button>
                    </div>
                </div>
            </div>

            <div class="sidebar">
                <!-- Document Preview will be populated here -->
                <div id="sidebarDocumentPreview" style="display: none;">
                    <h3>üìÑ Document Preview</h3>
                    <div id="sidebarFileInfo" class="alert alert-info" style="margin-bottom: 15px;">
                        <!-- File info will be populated here -->
                    </div>
                    <div style="background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 6px; padding: 10px;">
                        <div id="sidebarContentPreview" style="height: 600px; overflow-y: auto; background: white; border: 1px solid #ddd; border-radius: 4px;">
                            <!-- Content preview will be populated here -->
                        </div>
                    </div>
                </div>

                <!-- Default Instructions (shown when no document loaded) -->
                <div id="defaultInstructions">
                    <h3>üìã Question Extraction</h3>
                    <p>This step analyzes your document to:</p>
                    <ul>
                        <li><strong>Identify</strong> RFI questions</li>
                        <li><strong>Parse</strong> structured content</li>
                        <li><strong>Organize</strong> questions by category</li>
                        <li><strong>Prepare</strong> for answer generation</li>
                    </ul>
                    
                    <h4>üîç What We Look For</h4>
                    <ul>
                        <li>Numbered question lists</li>
                        <li>Structured RFI formats</li>
                        <li>Section-based questions</li>
                        <li>CSV question columns</li>
                    </ul>

                    <h4>‚ö° Next Steps</h4>
                    <p>After extraction, you'll be able to:</p>
                    <ul>
                        <li>Review identified questions</li>
                        <li>Edit or add questions manually</li>
                        <li>Proceed to answer generation</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script src="/static/js/app.js"></script>
    <script>
        let extractedQuestions = [];

        document.addEventListener('DOMContentLoaded', async () => {
            // Load session and check if we have a document
            const session = await getSession();
            console.log('Session loaded:', session);
            
            if (!session.processedContent || !session.documentName) {
                document.getElementById('documentStatus').innerHTML = `
                    <div class="alert alert-error">
                        No document found. Please <a href="/">upload a document</a> first.
                    </div>
                `;
                return;
            }

            // Show document info and extraction config
            document.getElementById('documentStatus').innerHTML = `
                <div class="alert alert-success">
                    <strong>Document ready:</strong> ${session.documentName}<br>
                    <small>Content length: ${session.processedContent.length} characters</small>
                </div>
            `;
            document.getElementById('extractionConfig').style.display = 'block';

            // Populate sidebar with document preview
            await populateSidebarPreview(session);

            // Set up event listeners
            setupEventListeners();
        });

        async function populateSidebarPreview(session) {
            const sidebarPreview = document.getElementById('sidebarDocumentPreview');
            const defaultInstructions = document.getElementById('defaultInstructions');
            const sidebarFileInfo = document.getElementById('sidebarFileInfo');
            const sidebarContentPreview = document.getElementById('sidebarContentPreview');
            
            if (!session.uploadedFile) {
                // No uploaded file, keep default instructions
                return;
            }

            // Hide default instructions, show preview
            defaultInstructions.style.display = 'none';
            sidebarPreview.style.display = 'block';

            // Populate file info
            const fileSizeKB = Math.round((session.processedContent?.length || 0) * 1.5 / 1024);
            sidebarFileInfo.innerHTML = `
                <strong>üìÑ ${session.documentName}</strong><br>
                <small>üìä Size: ~${fileSizeKB} KB | Type: ${session.uploadedFile.originalName?.split('.').pop()?.toUpperCase() || 'Unknown'}</small>
            `;

            // Render document content in sidebar
            const fileName = session.uploadedFile.originalName || '';
            console.log('File name for preview:', fileName);
            console.log('Session uploaded file:', session.uploadedFile);
            console.log('Session rawHtmlContent available:', !!session.rawHtmlContent);
            if (session.rawHtmlContent) {
                console.log('Raw HTML content length:', session.rawHtmlContent.length);
                console.log('Raw HTML content preview:', session.rawHtmlContent.substring(0, 200) + '...');
            }
            console.log('Session processedContent length:', session.processedContent?.length);
            console.log('All session keys:', Object.keys(session));
            
            if (fileName.toLowerCase().endsWith('.html') || fileName.toLowerCase().endsWith('.htm')) {
                console.log('Processing HTML file for preview - using EXACT upload page method');
                
                // Use EXACT same method as upload page
                try {
                    let uploadedFilePath = null;
                    if (session.uploadedFile.path) {
                        uploadedFilePath = session.uploadedFile.path.split('/').pop();
                    } else if (session.uploadedFile.filename) {
                        uploadedFilePath = session.uploadedFile.filename;
                    }
                    
                    console.log('Fetching from /uploads/:', uploadedFilePath);
                    
                    if (uploadedFilePath) {
                        const rawResponse = await fetch(`/uploads/${uploadedFilePath}`);
                        if (rawResponse.ok) {
                            const htmlContent = await rawResponse.text();
                            console.log('Successfully fetched HTML content, length:', htmlContent.length);
                            
                            // Create a safe iframe for HTML rendering - EXACT same as upload page
                            const iframe = document.createElement('iframe');
                            iframe.style.width = '100%';
                            iframe.style.height = '100%';
                            iframe.style.border = 'none';
                            iframe.style.background = 'white';
                            iframe.sandbox = 'allow-same-origin allow-scripts'; // Allow scripts for proper HTML rendering
                            
                            sidebarContentPreview.innerHTML = '';
                            sidebarContentPreview.appendChild(iframe);
                            
                            // Write HTML content to iframe - EXACT same as upload page
                            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                            iframeDoc.open();
                            iframeDoc.write(htmlContent);
                            iframeDoc.close();
                            
                            console.log('HTML content rendered successfully using upload page method');
                        } else {
                            console.warn('Failed to fetch file:', rawResponse.status, rawResponse.statusText);
                            sidebarContentPreview.innerHTML = `<div style="padding: 20px; text-align: center; color: #666;">
                                <p>Preview not available</p>
                                <small>Error loading HTML content</small>
                            </div>`;
                        }
                    }
                } catch (e) {
                    console.warn('Could not fetch HTML content:', e);
                    sidebarContentPreview.innerHTML = `<div style="padding: 20px; text-align: center; color: #666;">
                        <p>Preview not available</p>
                        <small>Error loading HTML content</small>
                    </div>`;
                }
            } else if (session.uploadedFile && (
                session.uploadedFile.mimetype === 'text/csv' || 
                session.uploadedFile.originalName?.toLowerCase().endsWith('.csv') ||
                session.documentName?.toLowerCase().endsWith('.csv')
            )) {
                // For CSV files, try to display as table
                console.log('DEBUG: Detected CSV file');
                console.log('DEBUG: Document name:', session.documentName);
                console.log('DEBUG: File mimetype:', session.uploadedFile?.mimetype);
                console.log('DEBUG: Original file name:', session.uploadedFile?.originalName);
                console.log('DEBUG: Upload file info:', session.uploadedFile);
                try {
                    await displayCSVAsTable(sidebarContentPreview, session);
                } catch (e) {
                    console.error('Could not display CSV as table:', e);
                    // Fallback to text display
                    const cleanContent = session.processedContent || 'No content available';
                    sidebarContentPreview.innerHTML = `<div style="padding: 15px; white-space: pre-wrap; font-family: 'DM Sans', system-ui, sans-serif; line-height: 1.5;">${cleanContent}</div>`;
                }
            } else {
                // For other files, show clean text content - same as upload page
                const cleanContent = session.processedContent || 'No content available';
                sidebarContentPreview.innerHTML = `<div style="padding: 15px; white-space: pre-wrap; font-family: 'DM Sans', system-ui, sans-serif; line-height: 1.5;">${cleanContent}</div>`;
            }
        }

        function setupEventListeners() {
            document.getElementById('extractBtn').addEventListener('click', extractQuestions);
            
            document.getElementById('proceedToGenerate').addEventListener('click', async () => {
                // Save extracted questions to session
                await updateSession({
                    extractedQuestions: extractedQuestions,
                    currentStep: 'generate'
                });
                window.location.href = '/generate';
            });

            document.getElementById('reExtract').addEventListener('click', () => {
                document.getElementById('extractionResults').style.display = 'none';
                document.getElementById('extractionConfig').style.display = 'block';
            });
        }

        async function extractQuestions() {
            const extractBtn = document.getElementById('extractBtn');
            const originalText = extractBtn.textContent;
            
            extractBtn.innerHTML = '<span class="loading"></span> Extracting...';
            extractBtn.disabled = true;

            try {
                const session = await getSession();
                const customPrompt = document.getElementById('customPrompt').value.trim();
                const selectedModel = document.getElementById('modelSelection').value;

                // Auto-detect extraction method based on content (like Streamlit version)
                let method = 'ai_extraction'; // Default method
                if (session.processedContent && (session.processedContent.includes('Q1:') || session.processedContent.includes('Question:'))) {
                    method = 'csv_direct';
                }

                const response = await fetch('/api/extract-questions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-Id': sessionId
                    },
                    body: JSON.stringify({
                        content: session.processedContent,
                        document_name: session.documentName,
                        extraction_method: method,
                        custom_prompt: customPrompt,
                        model_name: selectedModel
                    })
                });

                const result = await response.json();

                if (result.success && result.questions.length > 0) {
                    // Store raw questions from API
                    const rawQuestions = result.questions;
                    
                    // Display and flatten questions
                    displayQuestions(rawQuestions);
                    
                    // Use the flattened questions that displayQuestions creates
                    extractedQuestions = window.flattenedQuestions || rawQuestions;
                    
                    // Update success message
                    document.getElementById('successMessage').innerHTML = `
                        Successfully extracted <strong>${extractedQuestions.length} questions</strong> using ${method.replace('_', ' ')} method.
                    `;

                    // Show results, hide config
                    document.getElementById('extractionConfig').style.display = 'none';
                    document.getElementById('extractionResults').style.display = 'block';
                    
                    ARIA.showAlert(`Extracted ${extractedQuestions.length} questions successfully!`, 'success');
                } else {
                    // Check for specific error messages in the info object
                    let errorMessage = 'No questions found in the document';
                    
                    if (result.info?.error) {
                        errorMessage = result.info.error;
                    } else if (result.info?.errors && result.info.errors.length > 0) {
                        // Show the first error message (likely most relevant)
                        errorMessage = result.info.errors[0];
                    }
                    
                    ARIA.showAlert(errorMessage, 'error');
                }

            } catch (error) {
                console.error('Extraction error:', error);
                ARIA.showAlert('Failed to extract questions', 'error');
            } finally {
                extractBtn.textContent = originalText;
                extractBtn.disabled = false;
            }
        }

        function displayQuestions(questions) {
            console.log('Displaying questions - raw data:', questions);
            console.log('Questions type:', typeof questions);
            console.log('Questions is array:', Array.isArray(questions));
            if (Array.isArray(questions) && questions.length > 0) {
                console.log('First question item:', questions[0]);
                console.log('First question structure:', Object.keys(questions[0] || {}));
            }
            
            if (!questions || questions.length === 0) {
                document.getElementById('questionsTableBody').innerHTML = `
                    <tr>
                        <td colspan="4" style="padding: 40px; text-align: center; color: #666;">
                            <div class="alert alert-info">No questions found.</div>
                        </td>
                    </tr>
                `;
                return;
            }

            // Flatten the nested structure like in the Streamlit app
            const flattenedQuestions = flattenQuestionStructure(questions);
            console.log('Flattened questions:', flattenedQuestions);
            
            // Generate table rows
            const tableRows = flattenedQuestions.map((question, index) => {
                return `
                    <tr style="border-bottom: 1px solid #f0f0f0;" data-index="${index}">
                        <td style="padding: 12px; border-right: 1px solid #f0f0f0; font-family: monospace; font-weight: 600; color: #495057; background: #f8f9fa;">
                            ${escapeHtml(question.question || '')}
                        </td>
                        <td style="padding: 12px; border-right: 1px solid #f0f0f0; background: #f5f9ff;">
                            <div contenteditable="true" 
                                 class="editable-cell" 
                                 data-field="topic" 
                                 data-index="${index}"
                                 style="min-height: 20px; outline: none; padding: 4px; border-radius: 3px; transition: background-color 0.2s;"
                                 onfocus="this.style.backgroundColor='#e3f2fd'"
                                 onblur="this.style.backgroundColor='transparent'; updateQuestionField(${index}, 'topic', this.textContent)">
                                ${escapeHtml(question.topic || '')}
                            </div>
                        </td>
                        <td style="padding: 12px; border-right: 1px solid #f0f0f0; font-family: monospace; font-weight: 600; color: #495057;">
                            ${escapeHtml(question.sub_question || '')}
                        </td>
                        <td style="padding: 12px; background: #f7fbfe;">
                            <div contenteditable="true" 
                                 class="editable-cell" 
                                 data-field="text" 
                                 data-index="${index}"
                                 style="min-height: 20px; outline: none; padding: 4px; border-radius: 3px; line-height: 1.4; transition: background-color 0.2s;"
                                 onfocus="this.style.backgroundColor='#e8f5e8'"
                                 onblur="this.style.backgroundColor='transparent'; updateQuestionField(${index}, 'text', this.textContent)">
                                ${escapeHtml(question.text || '')}
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');

            document.getElementById('questionsTableBody').innerHTML = tableRows;
            
            // Store the flattened questions globally for editing
            window.flattenedQuestions = flattenedQuestions;
        }

        function flattenQuestionStructure(questions) {
            console.log('Input to flattenQuestionStructure:', questions);
            const flattened = [];
            
            if (!Array.isArray(questions)) {
                return flattened;
            }
            
            questions.forEach((item, i) => {
                console.log(`Processing item ${i}:`, item);
                
                if (typeof item === 'string') {
                    // Handle array of strings (fallback)
                    flattened.push({
                        question: String(i + 1),
                        topic: "General",
                        sub_question: `${i + 1}.1`,
                        text: item
                    });
                } else if (typeof item === 'object' && item !== null) {
                    // Handle the complex nested AI model structure with sub_topics
                    if (item.sub_topics && Array.isArray(item.sub_topics)) {
                        console.log(`Processing nested structure for question ${item.question}`);
                        
                        item.sub_topics.forEach((topicGroup) => {
                            const topicName = topicGroup.topic || 'General';
                            
                            if (topicGroup.sub_questions && Array.isArray(topicGroup.sub_questions)) {
                                topicGroup.sub_questions.forEach((subQ) => {
                                    flattened.push({
                                        question: item.question || String(i + 1),
                                        topic: topicName,
                                        sub_question: subQ.sub_question || `${item.question || (i + 1)}.1`,
                                        text: subQ.text || ''
                                    });
                                });
                            }
                        });
                    } 
                    // Handle simple flat structure (already normalized by backend)
                    else if (item.question && item.topic && item.sub_question && item.text) {
                        flattened.push({
                            question: item.question,
                            topic: item.topic,
                            sub_question: item.sub_question,
                            text: item.text
                        });
                    }
                    // Handle simple object structure (fallback)
                    else {
                        flattened.push({
                            question: item.question || String(i + 1),
                            topic: item.topic || 'General',
                            sub_question: item.sub_question || `${i + 1}.1`,
                            text: item.text || item.question || ''
                        });
                    }
                }
            });
            
            console.log('Flattened result:', flattened);
            return flattened;
        }

        function updateQuestionField(index, field, value) {
            if (window.flattenedQuestions && window.flattenedQuestions[index]) {
                window.flattenedQuestions[index][field] = value;
                console.log(`Updated question ${index} ${field}:`, value);
                
                // Auto-save changes
                saveQuestionsToSession();
            }
        }

        async function saveQuestionsToSession() {
            if (window.flattenedQuestions) {
                await updateSession({
                    extractedQuestions: window.flattenedQuestions
                });
                console.log('Questions saved to session');
            }
        }

        // Function to display CSV as table (same as upload page)
        async function displayCSVAsTable(contentPreview, session) {
            // For extract page, we need to get the file from uploads directory
            const fileName = session.uploadedFile?.filename || session.documentName;
            console.log('DEBUG: Trying to fetch CSV file:', fileName);
            console.log('DEBUG: Upload file object:', session.uploadedFile);
            
            if (!fileName) {
                throw new Error('No file name available');
            }
            
            // Fetch the raw CSV file content
            const csvUrl = `/uploads/${fileName}`;
            console.log('DEBUG: Fetching CSV from URL:', csvUrl);
            const csvResponse = await fetch(csvUrl);
            if (!csvResponse.ok) {
                throw new Error('Could not fetch CSV file');
            }
            
            const csvText = await csvResponse.text();
            
            // Parse CSV manually (simple parsing for preview)
            const lines = csvText.trim().split('\n');
            if (lines.length === 0) {
                throw new Error('CSV file is empty');
            }
            
            // Parse CSV rows (handle basic quoting)
            const parseCSVLine = (line) => {
                const result = [];
                let current = '';
                let inQuotes = false;
                let i = 0;
                
                while (i < line.length) {
                    const char = line[i];
                    const nextChar = line[i + 1];
                    
                    if (char === '"') {
                        if (inQuotes && nextChar === '"') {
                            // Escaped quote
                            current += '"';
                            i += 2;
                        } else {
                            // Toggle quote state
                            inQuotes = !inQuotes;
                            i += 1;
                        }
                    } else if (char === ',' && !inQuotes) {
                        // Field separator
                        result.push(current.trim());
                        current = '';
                        i += 1;
                    } else {
                        current += char;
                        i += 1;
                    }
                }
                
                result.push(current.trim());
                return result;
            };
            
            const rows = lines.map(parseCSVLine);
            const headers = rows[0];
            const dataRows = rows.slice(1);
            
            // Limit display to first 50 rows for performance (smaller for sidebar)
            const displayRows = dataRows.slice(0, 50);
            const hasMoreRows = dataRows.length > 50;
            
            // Build HTML table (adjusted for sidebar display)
            let tableHTML = `
                <div style="padding: 10px;">
                    <div style="margin-bottom: 8px;">
                        <h4 style="margin: 0; color: #333; font-size: 14px;">CSV Preview</h4>
                        <small style="color: #666; font-size: 11px;">
                            ${headers.length} columns, ${dataRows.length} rows${hasMoreRows ? ' (showing first 50)' : ''}
                        </small>
                    </div>
                    <div style="overflow-x: auto; max-height: 800px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;">
                        <table style="width: 100%; border-collapse: collapse; font-size: 12px; background: white;">
                            <thead style="background: #f8f9fa; position: sticky; top: 0; z-index: 10;">
                                <tr>`;
            
            // Add headers (limit column width for sidebar)
            headers.forEach(header => {
                tableHTML += `<th style="padding: 6px 8px; text-align: left; border-bottom: 2px solid #dee2e6; border-right: 1px solid #dee2e6; font-weight: 600; white-space: nowrap; max-width: 120px; overflow: hidden; text-overflow: ellipsis;" title="${escapeHtml(header)}">${escapeHtml(header)}</th>`;
            });
            
            tableHTML += `</tr></thead><tbody>`;
            
            // Add data rows
            displayRows.forEach((row, rowIndex) => {
                const isEvenRow = rowIndex % 2 === 0;
                tableHTML += `<tr style="background: ${isEvenRow ? 'white' : '#f9f9f9'};">`;
                
                headers.forEach((header, colIndex) => {
                    const cellValue = row[colIndex] || '';
                    const truncatedValue = cellValue.length > 60 ? cellValue.substring(0, 60) + '...' : cellValue;
                    tableHTML += `<td style="padding: 4px 8px; border-bottom: 1px solid #dee2e6; border-right: 1px solid #dee2e6; vertical-align: top; max-width: 120px; word-wrap: break-word; font-size: 11px;" title="${escapeHtml(cellValue)}">${escapeHtml(truncatedValue)}</td>`;
                });
                
                tableHTML += `</tr>`;
            });
            
            tableHTML += `</tbody></table></div>`;
            
            if (hasMoreRows) {
                tableHTML += `<div style="padding: 8px; text-align: center; color: #666; font-size: 10px;">...and ${dataRows.length - 50} more rows</div>`;
            }
            
            tableHTML += `</div>`;
            
            contentPreview.innerHTML = tableHTML;
        }

        // Helper function to escape HTML
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
    </script>
</body>
</html>
